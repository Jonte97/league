// Generated by https://quicktype.io

namespace QuickType
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class RootChampionDto
    {
        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("format")]
        public string Format { get; set; }

        [JsonProperty("version")]
        public string Version { get; set; }

        [JsonProperty("data")]
        public Dictionary<string, Champion> Data { get; set; }
        
    }

    public partial class Champion
    {
        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("key")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Key { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("title")]
        public string Title { get; set; }

        [JsonProperty("image")]
        public Image Image { get; set; }

        [JsonProperty("skins")]
        public Skin[] Skins { get; set; }

        [JsonProperty("lore")]
        public string Lore { get; set; }

        [JsonProperty("blurb")]
        public string Blurb { get; set; }

        [JsonProperty("allytips")]
        public string[] Allytips { get; set; }

        [JsonProperty("enemytips")]
        public string[] Enemytips { get; set; }

        [JsonProperty("tags")]
        public string[] Tags { get; set; }

        [JsonProperty("partype")]
        public string Partype { get; set; }

        [JsonProperty("info")]
        public Info Info { get; set; }

        [JsonProperty("stats")]
        public Dictionary<string, double> Stats { get; set; }

        [JsonProperty("spells")]
        public Spell[] Spells { get; set; }

        [JsonProperty("passive")]
        public Passive Passive { get; set; }

        [JsonProperty("recommended")]
        public Recommended[] Recommended { get; set; }
    }

    public partial class Image
    {
        [JsonProperty("full")]
        public string Full { get; set; }

        [JsonProperty("sprite")]
        public string Sprite { get; set; }

        [JsonProperty("group")]
        public string Group { get; set; }

        [JsonProperty("x")]
        public long X { get; set; }

        [JsonProperty("y")]
        public long Y { get; set; }

        [JsonProperty("w")]
        public long W { get; set; }

        [JsonProperty("h")]
        public long H { get; set; }
    }

    public partial class Info
    {
        [JsonProperty("attack")]
        public long Attack { get; set; }

        [JsonProperty("defense")]
        public long Defense { get; set; }

        [JsonProperty("magic")]
        public long Magic { get; set; }

        [JsonProperty("difficulty")]
        public long Difficulty { get; set; }
    }

    public partial class Passive
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("description")]
        public string Description { get; set; }

        [JsonProperty("image")]
        public Image Image { get; set; }
    }

    public partial class Recommended
    {
        [JsonProperty("champion")]
        public string Champion { get; set; }

        [JsonProperty("title")]
        public string Title { get; set; }

        [JsonProperty("map")]
        public string Map { get; set; }

        [JsonProperty("mode")]
        public string Mode { get; set; }

        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("customTag", NullValueHandling = NullValueHandling.Ignore)]
        public string CustomTag { get; set; }

        [JsonProperty("sortrank", NullValueHandling = NullValueHandling.Ignore)]
        public long? Sortrank { get; set; }

        [JsonProperty("extensionPage", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ExtensionPage { get; set; }

        [JsonProperty("customPanel")]
        public object CustomPanel { get; set; }

        [JsonProperty("blocks")]
        public Block[] Blocks { get; set; }

        [JsonProperty("useObviousCheckmark", NullValueHandling = NullValueHandling.Ignore)]
        public bool? UseObviousCheckmark { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Priority { get; set; }
    }

    public partial class Block
    {
        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("recMath", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RecMath { get; set; }

        [JsonProperty("recSteps", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RecSteps { get; set; }

        [JsonProperty("minSummonerLevel", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinSummonerLevel { get; set; }

        [JsonProperty("maxSummonerLevel", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxSummonerLevel { get; set; }

        [JsonProperty("showIfSummonerSpell", NullValueHandling = NullValueHandling.Ignore)]
        public IfSummonerSpell? ShowIfSummonerSpell { get; set; }

        [JsonProperty("hideIfSummonerSpell", NullValueHandling = NullValueHandling.Ignore)]
        public IfSummonerSpell? HideIfSummonerSpell { get; set; }

        [JsonProperty("appendAfterSection", NullValueHandling = NullValueHandling.Ignore)]
        public string AppendAfterSection { get; set; }

        [JsonProperty("visibleWithAllOf", NullValueHandling = NullValueHandling.Ignore)]
        public string[] VisibleWithAllOf { get; set; }

        [JsonProperty("hiddenWithAnyOf", NullValueHandling = NullValueHandling.Ignore)]
        public string[] HiddenWithAnyOf { get; set; }

        [JsonProperty("items")]
        public Item[] Items { get; set; }
    }

    public partial class Item
    {
        [JsonProperty("id")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Id { get; set; }

        [JsonProperty("count")]
        public long Count { get; set; }

        [JsonProperty("hideCount", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HideCount { get; set; }
    }

    public partial class Skin
    {
        [JsonProperty("id")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Id { get; set; }

        [JsonProperty("num")]
        public long Num { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("chromas")]
        public bool Chromas { get; set; }
    }

    public partial class Spell
    {
        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("description")]
        public string Description { get; set; }

        [JsonProperty("tooltip")]
        public string Tooltip { get; set; }

        [JsonProperty("leveltip")]
        public Leveltip Leveltip { get; set; }

        [JsonProperty("maxrank")]
        public long Maxrank { get; set; }

        [JsonProperty("cooldown")]
        public long[] Cooldown { get; set; }

        [JsonProperty("cooldownBurn")]
        public string CooldownBurn { get; set; }

        [JsonProperty("cost")]
        public long[] Cost { get; set; }

        [JsonProperty("costBurn")]
        public string CostBurn { get; set; }

        [JsonProperty("datavalues")]
        public Datavalues Datavalues { get; set; }

        [JsonProperty("effect")]
        public double[][] Effect { get; set; }

        [JsonProperty("effectBurn")]
        public string[] EffectBurn { get; set; }

        [JsonProperty("vars")]
        public Var[] Vars { get; set; }

        [JsonProperty("costType")]
        public string CostType { get; set; }

        [JsonProperty("maxammo")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Maxammo { get; set; }

        [JsonProperty("range")]
        public long[] Range { get; set; }

        [JsonProperty("rangeBurn")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long RangeBurn { get; set; }

        [JsonProperty("image")]
        public Image Image { get; set; }

        [JsonProperty("resource")]
        public string Resource { get; set; }
    }

    public partial class Datavalues
    {
    }

    public partial class Leveltip
    {
        [JsonProperty("label")]
        public string[] Label { get; set; }

        [JsonProperty("effect")]
        public string[] Effect { get; set; }
    }

    public partial class Var
    {
        [JsonProperty("link")]
        public string Link { get; set; }

        [JsonProperty("coeff")]
        public double Coeff { get; set; }

        [JsonProperty("key")]
        public string Key { get; set; }
    }

    public enum IfSummonerSpell { Empty, SummonerSmite };

    public partial class RootChampionDto
    {
        public static RootChampionDto FromJson(string json) => JsonConvert.DeserializeObject<RootChampionDto>(json, QuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this RootChampionDto self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters = {
                IfSummonerSpellConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class IfSummonerSpellConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(IfSummonerSpell) || t == typeof(IfSummonerSpell?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return IfSummonerSpell.Empty;
                case "SummonerSmite":
                    return IfSummonerSpell.SummonerSmite;
            }
            throw new Exception("Cannot unmarshal type IfSummonerSpell");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (IfSummonerSpell)untypedValue;
            switch (value)
            {
                case IfSummonerSpell.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case IfSummonerSpell.SummonerSmite:
                    serializer.Serialize(writer, "SummonerSmite");
                    return;
            }
            throw new Exception("Cannot marshal type IfSummonerSpell");
        }

        public static readonly IfSummonerSpellConverter Singleton = new IfSummonerSpellConverter();
    }
}
