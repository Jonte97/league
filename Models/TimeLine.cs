// Generated by https://quicktype.io

namespace TimeLineNS
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using System.Runtime.Serialization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class TimeLine
    {
        [JsonProperty("frames")]
        public Frame[] Frames { get; set; }

        [JsonProperty("frameInterval")]
        public long FrameInterval { get; set; }
    }

    public partial class Frame
    {
        [JsonProperty("participantFrames")]
        public Dictionary<string, ParticipantFrame> ParticipantFrames { get; set; }

        [JsonProperty("events")]
        public Event[] Events { get; set; }

        [JsonProperty("timestamp")]
        public long Timestamp { get; set; }
    }

    public partial class Event
    {
        [JsonProperty("type")]
        public TypeEnum Type { get; set; }

        [JsonProperty("timestamp")]
        public long Timestamp { get; set; }

        [JsonProperty("participantId", NullValueHandling = NullValueHandling.Ignore)]
        public long? ParticipantId { get; set; }

        [JsonProperty("itemId", NullValueHandling = NullValueHandling.Ignore)]
        public long? ItemId { get; set; }

        [JsonProperty("quantity", NullValueHandling = NullValueHandling.Ignore)]
        public int? Quantity { get; set; }
        
        [JsonProperty("skillSlot", NullValueHandling = NullValueHandling.Ignore)]
        public long? SkillSlot { get; set; }

        [JsonProperty("levelUpType", NullValueHandling = NullValueHandling.Ignore)]
        public LevelUpType? LevelUpType { get; set; }

        [JsonProperty("wardType", NullValueHandling = NullValueHandling.Ignore)]
        public WardType? WardType { get; set; }

        [JsonProperty("creatorId", NullValueHandling = NullValueHandling.Ignore)]
        public long? CreatorId { get; set; }

        [JsonProperty("position", NullValueHandling = NullValueHandling.Ignore)]
        public Position Position { get; set; }

        [JsonProperty("killerId", NullValueHandling = NullValueHandling.Ignore)]
        public long? KillerId { get; set; }

        [JsonProperty("victimId", NullValueHandling = NullValueHandling.Ignore)]
        public long? VictimId { get; set; }

        [JsonProperty("assistingParticipantIds", NullValueHandling = NullValueHandling.Ignore)]
        public long[] AssistingParticipantIds { get; set; }

        [JsonProperty("afterId", NullValueHandling = NullValueHandling.Ignore)]
        public long? AfterId { get; set; }

        [JsonProperty("beforeId", NullValueHandling = NullValueHandling.Ignore)]
        public long? BeforeId { get; set; }

        [JsonProperty("monsterType", NullValueHandling = NullValueHandling.Ignore)]
        public string MonsterType { get; set; }

        [JsonProperty("monsterSubType", NullValueHandling = NullValueHandling.Ignore)]
        public string MonsterSubType { get; set; }

        [JsonProperty("teamId", NullValueHandling = NullValueHandling.Ignore)]
        public long? TeamId { get; set; }

        [JsonProperty("buildingType", NullValueHandling = NullValueHandling.Ignore)]
        public BuildingType? BuildingType { get; set; }

        [JsonProperty("laneType", NullValueHandling = NullValueHandling.Ignore)]
        public LaneType? LaneType { get; set; }

        [JsonProperty("towerType", NullValueHandling = NullValueHandling.Ignore)]
        public string TowerType { get; set; }
    }

    public partial class Position
    {
        [JsonProperty("x")]
        public long X { get; set; }

        [JsonProperty("y")]
        public long Y { get; set; }
    }

    public partial class ParticipantFrame
    {
        [JsonProperty("participantId")]
        public long ParticipantId { get; set; }

        [JsonProperty("position")]
        public Position Position { get; set; }

        [JsonProperty("currentGold")]
        public long CurrentGold { get; set; }

        [JsonProperty("totalGold")]
        public long TotalGold { get; set; }

        [JsonProperty("level")]
        public long Level { get; set; }

        [JsonProperty("xp")]
        public long Xp { get; set; }

        [JsonProperty("minionsKilled")]
        public long MinionsKilled { get; set; }

        [JsonProperty("jungleMinionsKilled")]
        public long JungleMinionsKilled { get; set; }

        [JsonProperty("dominionScore")]
        public long DominionScore { get; set; }

        [JsonProperty("teamScore")]
        public long TeamScore { get; set; }
    }

    [JsonConverter(typeof(StringEnumConverter))]
    public enum BuildingType { 
        [EnumMember(Value = "INHIBITOR_BUILDING")]
        InhibitorBuilding, 
        [EnumMember(Value = "TOWER_BUILDING")]
        TowerBuilding };

    [JsonConverter(typeof(StringEnumConverter))]
    public enum LaneType
    {
        [EnumMember(Value = "BOT_LANE")]
        BotLane,
        [EnumMember(Value = "MID_LANE")]
        MidLane,
        [EnumMember(Value = "TOP_LANE")]
        TopLane
    };

    [JsonConverter(typeof(StringEnumConverter))]
    public enum LevelUpType
    {
        [EnumMember(Value = "EVOLVE")]
        Evolve,
        [EnumMember(Value = "NORMAL")]
        Normal
    };

    [JsonConverter(typeof(StringEnumConverter))]
    public enum TypeEnum
    {
        [EnumMember(Value = "BUILDING_KILL")]
        BuildingKill,
        [EnumMember(Value = "CHAMPION_KILL")]
        ChampionKill,
        [EnumMember(Value = "ELITE_MONSTER_KILL")]
        EliteMonsterKill,
        [EnumMember(Value = "ITEM_DESTROYED")]
        ItemDestroyed,
        [EnumMember(Value = "ITEM_PURCHASED")]
        ItemPurchased,
        [EnumMember(Value = "ITEM_SOLD")]
        ItemSold,
        [EnumMember(Value = "ITEM_UNDO")]
        ItemUndo,
        [EnumMember(Value = "SKILL_LEVEL_UP")]
        SkillLevelUp,
        [EnumMember(Value = "WARD_KILL")]
        WardKill,
        [EnumMember(Value = "WARD_PLACED")]
        WardPlaced
    };
    [JsonConverter(typeof(StringEnumConverter))]
    public enum WardType
    {
        [EnumMember(Value = "BLUE_TRINKET")]
        BlueTrinket,
        [EnumMember(Value = "CONTROL_WARD")]
        ControlWard,
        [EnumMember(Value = "SIGHT_WARD")]
        SightWard,
        [EnumMember(Value = "UNDEFINED")]
        Undefined,
        [EnumMember(Value = "YELLOW_TRINKET")]
        YellowTrinket,
        [EnumMember(Value = "TEEMO_MUSHROOM")]
        TeemoMushroom        
    };

    public partial class TimeLine
    {
        public static TimeLine FromJson(string json) => JsonConvert.DeserializeObject<TimeLine>(json, QuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this TimeLine self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters = {
                BuildingTypeConverter.Singleton,
                LaneTypeConverter.Singleton,
                LevelUpTypeConverter.Singleton,
                TypeEnumConverter.Singleton,
                WardTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class BuildingTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BuildingType) || t == typeof(BuildingType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "INHIBITOR_BUILDING":
                    return BuildingType.InhibitorBuilding;
                case "TOWER_BUILDING":
                    return BuildingType.TowerBuilding;
            }
            throw new Exception("Cannot unmarshal type BuildingType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BuildingType)untypedValue;
            switch (value)
            {
                case BuildingType.InhibitorBuilding:
                    serializer.Serialize(writer, "INHIBITOR_BUILDING");
                    return;
                case BuildingType.TowerBuilding:
                    serializer.Serialize(writer, "TOWER_BUILDING");
                    return;
            }
            throw new Exception("Cannot marshal type BuildingType");
        }

        public static readonly BuildingTypeConverter Singleton = new BuildingTypeConverter();
    }

    internal class LaneTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LaneType) || t == typeof(LaneType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "BOT_LANE":
                    return LaneType.BotLane;
                case "MID_LANE":
                    return LaneType.MidLane;
                case "TOP_LANE":
                    return LaneType.TopLane;
            }
            throw new Exception("Cannot unmarshal type LaneType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LaneType)untypedValue;
            switch (value)
            {
                case LaneType.BotLane:
                    serializer.Serialize(writer, "BOT_LANE");
                    return;
                case LaneType.MidLane:
                    serializer.Serialize(writer, "MID_LANE");
                    return;
                case LaneType.TopLane:
                    serializer.Serialize(writer, "TOP_LANE");
                    return;
            }
            throw new Exception("Cannot marshal type LaneType");
        }

        public static readonly LaneTypeConverter Singleton = new LaneTypeConverter();
    }

    internal class LevelUpTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LevelUpType) || t == typeof(LevelUpType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "EVOLVE":
                    return LevelUpType.Evolve;
                case "NORMAL":
                    return LevelUpType.Normal;
            }
            throw new Exception("Cannot unmarshal type LevelUpType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LevelUpType)untypedValue;
            switch (value)
            {
                case LevelUpType.Evolve:
                    serializer.Serialize(writer, "EVOLVE");
                    return;
                case LevelUpType.Normal:
                    serializer.Serialize(writer, "NORMAL");
                    return;
            }
            throw new Exception("Cannot marshal type LevelUpType");
        }

        public static readonly LevelUpTypeConverter Singleton = new LevelUpTypeConverter();
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "BUILDING_KILL":
                    return TypeEnum.BuildingKill;
                case "CHAMPION_KILL":
                    return TypeEnum.ChampionKill;
                case "ELITE_MONSTER_KILL":
                    return TypeEnum.EliteMonsterKill;
                case "ITEM_DESTROYED":
                    return TypeEnum.ItemDestroyed;
                case "ITEM_PURCHASED":
                    return TypeEnum.ItemPurchased;
                case "ITEM_SOLD":
                    return TypeEnum.ItemSold;
                case "ITEM_UNDO":
                    return TypeEnum.ItemUndo;
                case "SKILL_LEVEL_UP":
                    return TypeEnum.SkillLevelUp;
                case "WARD_KILL":
                    return TypeEnum.WardKill;
                case "WARD_PLACED":
                    return TypeEnum.WardPlaced;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            switch (value)
            {
                case TypeEnum.BuildingKill:
                    serializer.Serialize(writer, "BUILDING_KILL");
                    return;
                case TypeEnum.ChampionKill:
                    serializer.Serialize(writer, "CHAMPION_KILL");
                    return;
                case TypeEnum.EliteMonsterKill:
                    serializer.Serialize(writer, "ELITE_MONSTER_KILL");
                    return;
                case TypeEnum.ItemDestroyed:
                    serializer.Serialize(writer, "ITEM_DESTROYED");
                    return;
                case TypeEnum.ItemPurchased:
                    serializer.Serialize(writer, "ITEM_PURCHASED");
                    return;
                case TypeEnum.ItemSold:
                    serializer.Serialize(writer, "ITEM_SOLD");
                    return;
                case TypeEnum.ItemUndo:
                    serializer.Serialize(writer, "ITEM_UNDO");
                    return;
                case TypeEnum.SkillLevelUp:
                    serializer.Serialize(writer, "SKILL_LEVEL_UP");
                    return;
                case TypeEnum.WardKill:
                    serializer.Serialize(writer, "WARD_KILL");
                    return;
                case TypeEnum.WardPlaced:
                    serializer.Serialize(writer, "WARD_PLACED");
                    return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }

    internal class WardTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(WardType) || t == typeof(WardType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "BLUE_TRINKET":
                    return WardType.BlueTrinket;
                case "CONTROL_WARD":
                    return WardType.ControlWard;
                case "SIGHT_WARD":
                    return WardType.SightWard;
                case "UNDEFINED":
                    return WardType.Undefined;
                case "YELLOW_TRINKET":
                    return WardType.YellowTrinket;
            }
            throw new Exception("Cannot unmarshal type WardType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (WardType)untypedValue;
            switch (value)
            {
                case WardType.BlueTrinket:
                    serializer.Serialize(writer, "BLUE_TRINKET");
                    return;
                case WardType.ControlWard:
                    serializer.Serialize(writer, "CONTROL_WARD");
                    return;
                case WardType.SightWard:
                    serializer.Serialize(writer, "SIGHT_WARD");
                    return;
                case WardType.Undefined:
                    serializer.Serialize(writer, "UNDEFINED");
                    return;
                case WardType.YellowTrinket:
                    serializer.Serialize(writer, "YELLOW_TRINKET");
                    return;
            }
            throw new Exception("Cannot marshal type WardType");
        }

        public static readonly WardTypeConverter Singleton = new WardTypeConverter();
    }
}
